# 算子维度划分介绍

# 维度一：依赖维度

```json
# 算子难度评判方案

## 维度1. 指令集差异程度

本维度旨在为 NCNN 算子从 x86 SSE/AVX/AVX512 架构到 RISC-V RVV 架构的迁移工作，提供一个清晰、可量化的**指令集差异程度**评估标准。

的评判，核心依据是分析算子实现中所使用的 x86 SSE/AVX/AVX512 Intrinsics，评估其迁移到 RVV 的难度。

### 2. 难度等级定义

#### Level 1：低难度 (直接映射)
功能重叠的算子 (可以直接或概念上直接迁移)
这部分算子在两种架构中都有直接或非常相似的功能对应，是跨架构迁移时最容易处理的部分。

---

#### Level 2：高难度 (组合模拟)
 X86 SSE/AVX/AVX512 独特或惯用的算子
这部分算子在RVV中没有直接的单指令对应，迁移时通常需要用多条RVV指令组合模拟，或者需要重新设计算法。

## 维度2.依赖链需迁移程度
重新审视现在的问题：
  - 所有代码都有显式/隐式依赖和长/短依赖，而且经统计发现opencv arm下各算子的依赖项规模较小(1-5个头文件)，对于Agent、LLM来说，不是什么大问题。
  - 所以体现不出我们的亮点
---
那么在针对不同架构进行算子迁移的任务中，这些依赖项有什么与众不同的地方呢<br>
最关键的点是：**依赖本身是否需要迁移**，因为普通的软件重构任务中，这些依赖链多多少少都是能用的，不需要大面积重写，是代码组织形式上的改写，而我们的迁移任务中，有绑定架构的依赖链，是无法直接使用的，必须针对特定架构进行重写，是代码内容根本上的改写。

那么我们根据算子依赖的统计情况，有如下判断依赖本身是否需要迁移的方案：
1. **识别架构绑定的模块**：
- 通过分析依赖头文件的实现内容和头文件的特性[大家一起用]，我们将它们分为两类，根据**是否深度依赖特定架构的指令实现**
	 - 架构无关模块：layer_type.h, mat.h[基础工具模块]，模块内的函数在任何架构上都可以直接复用
	- 架构绑定模块：x86_usability.h, x86_activation.h, sse_mathfun.h,avx_mathfun.h, avx_mathfun.h
2.**对依赖链进行分类**
- **架构无关类的依赖链**：**算子的所有依赖（显式+隐式）都是架构无关的**，迁移成本是固定的、一次性的，一旦迁移完成，所有依赖它的算子都可以直接使用。迁移这类算子重点在关注算子本身，**无需协调迁移策略**。
	- 该类算子对于agent来说，迁移的难度**主要体现在正确替换算子内的NEON intrinsic（这由另一个硬件调用维度评估）**。
- **架构相关类的依赖链**：**算子的依赖链，无论是显示或隐式依赖，至少有一个是架构相关的**，迁移这类算子不仅要关注算子本身，还要如何整体迁移依赖链，因为这些模块被多个算子共用，**需要协调迁移策略**[如：统一接口设计，不断增加、优化算子分发层的配置，是否已存在针对某架构迁移的接口，这都需要在迁移各个算子时，逐渐完成迁移]。
	- 这类算字对于agent来说，迁移的难度在于**不仅需要正确迁移算子本身，还需协调迁移依赖链**。
 
---
## 两个维度如何分别评估Agent 的能力
|维度	|评估内容|测试的Agent能力|
|---|---|---|
|依赖链需迁移程度	|要迁移多少内容|• 依赖发现能力（能否找到隐式依赖）<br>• 依赖判断：能否区分架构无关 vs 架构绑定模块<br>• 上下文管理能力（读取多少文件）<br>• 模块协调能力（如何处理共用模块）|
|指令集差异程度	|怎么进行迁移|• 指令理解能力（是否知道vtbl的语义）<br>• 架构知识（是否知道RVV的对应指令）<br>• 算法设计能力（能否设计等价实现）|

----
## 最终难度分级
||依赖架构无关|依赖架构相关|
|---|---|---|
|**指令直接映射**|直接映射+迁移算子|直接映射+迁移算子和依赖链|
|**指令组合重构**|组合重构+迁移算子|组合重构+迁移算子和依赖链|
```

# 维度二：硬件维度

## 一、分级核心定位

本维度聚焦 SSE/AVX/AVX512指令集到 RVV 指令集的迁移场景，核心衡量算子迁移过程中因架构指令集差异带来的技术难度，为 NCNN 算子迁移 Benchmark 提供硬件适配层面的标准化评估依据，确保迁移难度评估贴合底层技术实现逻辑。

## 二、评估方法

采用 **“特征指令识别法”**：通过解析算子源代码中包含的 SSE/AVX/AVX512特征指令，以“最高难度等级的特征指令”作为核心判定依据，直接确定该算子的硬件调用难度等级。

## 三、分级标准

### 1. H=1（直接迁移）

- **核心定义**：算子仅使用 SSE/AVX/AVX512 基础指令，无复杂指令逻辑，可直接映射为 RVV 对应指令实现迁移，无需额外修改算法或指令组合逻辑。
- **特征指令类型**：基础算术指令（如加法、减法、乘法）、逻辑指令（与、或、非）、比较指令（大于、小于、等于）等无架构特异性的通用指令。
- **迁移特点**：指令一对一映射，迁移过程简单高效，无额外技术难点，仅需适配 RVV 指令语法与寄存器使用规则。

### 2. H=2（需要重构）

- **核心定义**：算子包含 SSE/AVX/AVX512 复杂特征指令，这类指令与 RVV 架构存在根本性差异，无法直接映射实现，需通过多条 RVV 指令组合模拟，或重构算法逻辑才能完成迁移。
- **特征指令类型**：
    - 组合模拟类：需多步 RVV 指令协同组合实现的指令；
    - 架构差异类：_mm_unpacklo_epi8/_mm_unpackhi_epi8(寄存器交织/拆分)，_mm_shuffle_epi8(元素反转），_mm_alignr_epi8（跨寄存器抽取），_mm_shuffle_epi8（任意字节置换）等x86架构专有指令，RVV无对应等价指令；
- **迁移特点**：需深入理解两种架构的指令集设计逻辑，要么通过指令组合模拟原功能，要么重新设计算法流程规避不兼容指令，迁移技术难度较高，对实现者的硬件架构认知有一定要求。